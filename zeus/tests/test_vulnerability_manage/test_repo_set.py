#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import json
import unittest
from unittest import mock

import responses
from flask import Flask

from vulcanus.conf.constant import EXECUTE_REPO_SET
from vulcanus.multi_thread_handler import MultiThreadHandler
from vulcanus.restful.status import (
    DATABASE_CONNECT_ERROR,
    DATABASE_QUERY_ERROR,
    PARAM_ERROR,
    SUCCEED,
    TOKEN_ERROR
)
from zeus import BLUE_POINT
from zeus.account_manager.cache import UserCache, UserInfo
from zeus.conf.constant import CERES_CVE_REPO_SET
from zeus.vulnerability_manage.view import ExecuteRepoSetTask

app = Flask("test")
for blue, api in BLUE_POINT:
    api.init_app(blue)
    app.register_blueprint(blue)

app.testing = True
client = app.test_client()


class TestRepoSet(unittest.TestCase):
    HEADERS = {
        "Content-Type": "application/json; charset=UTF-8"
    }
    HEADERS_WITH_TOKEN = {
        "Content-Type": "application/json; charset=UTF-8",
        "access_token": "mock_token"
    }

    MOCK_HOST_INFO = {
        "mock_id_1": {
            "name": "host_name_1",
            "ip": "host_ip_1",
            "address": "host_ip_1:host_port"
        },
        "mock_id_2": {
            "name": "host_name_2",
            "ip": "host_ip_2",
            "address": "host_ip_2:host_port"
        }
    }

    def setUp(self) -> None:
        self.MOCK_ARGS = {
            "task_id": "mock_task",
            "task_name": "mock_task_name",
            "task_type": "mock_task_type",
            "total_hosts": ["mock_id_1", "mock_id_2"],
            "check_items": [],
            "repo_info": {
                "name": "mock_repo_name",

                "dest": "mock_path",
                "repo_content": "mock_content"
            },
            "tasks": [
                {
                    "host_id": "mock_id_1",
                    "check": False
                },
                {
                    "host_id": "mock_id_2",
                    "check": False
                }
            ],
            "callback": ""
        }

    @mock.patch.object(MultiThreadHandler, "get_result")
    @mock.patch.object(MultiThreadHandler, "create_thread")
    @mock.patch('zeus.vulnerability_manage.view.query_host_basic_info')
    @mock.patch.object(UserCache, 'get')
    def test_repo_set_should_return_execute_result_when_all_is_right_without_callback(
            self, mock_user, mock_query_host_info, mock_create_thread, mock_get_result):
        mock_user.return_value = UserInfo('admin', 'mock', 'mock')
        mock_query_host_info.return_value = SUCCEED, self.MOCK_HOST_INFO
        mock_create_thread.return_value = None
        mock_get_result.return_value = [
            {
                'code': SUCCEED,
                'msg': 'operation succeed',
                'host_id': 'mock_id_1',
                'task_id': 'mock_task',
                'host_name': 'host_name_1',
                'host_ip': 'host_ip_1',
                'repo': 'mock_repo_name',
                'callback': '',
                "headers_apollo": {}
            },
            {
                'code': SUCCEED,
                'msg': 'operation succeed',
                'host_id': 'mock_id_2',
                'task_id': 'mock_task',
                'host_name': 'host_name_2',
                'host_ip': 'host_ip_2',
                'repo': 'mock_repo_name',
                'callback': '',
                "headers_apollo": {}
            },
        ]
        response = client.post(EXECUTE_REPO_SET,
                               data=json.dumps(self.MOCK_ARGS),
                               headers=self.HEADERS_WITH_TOKEN)
        expect_result = {
            "code": 200,
            "msg": "operation succeed",
            "result": {
                "task_id": "mock_task",
                "task_name": "mock_task_name",
                "task_type": "mock_task_type",
                "task_result": [
                    {
                        "host_id": "mock_id_1",
                        "host_ip": "host_ip_1",
                        "host_name": "host_name_1",
                        "log": "operation succeed",
                        "repo": "mock_repo_name",
                        "status": "succeed"
                    },
                    {
                        "host_id": "mock_id_2",
                        "host_ip": "host_ip_2",
                        "host_name": "host_name_2",
                        "log": "operation succeed",
                        "repo": "mock_repo_name",
                        "status": "succeed"
                    }
                ]
            }
        }
        self.assertEqual(expect_result, response.json)

    @mock.patch.object(ExecuteRepoSetTask, '_callback')
    @mock.patch.object(MultiThreadHandler, "create_thread")
    @mock.patch('zeus.vulnerability_manage.view.query_host_basic_info')
    @mock.patch.object(UserCache, 'get')
    def test_repo_set_should_return_succeed_when_all_is_right_with_callback(
            self, mock_user, mock_query_host_info, mock_create_thread, mock_callback):
        mock_user.return_value = UserInfo('admin', 'mock', 'mock')
        mock_query_host_info.return_value = SUCCEED, self.MOCK_HOST_INFO
        mock_create_thread.return_value = None
        mock_callback.return_value = None
        self.MOCK_ARGS['callback'] = 'mock_callback'
        response = client.post(EXECUTE_REPO_SET,
                               data=json.dumps(self.MOCK_ARGS),
                               headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(SUCCEED, response.json.get('code'))

    def test_repo_should_return_token_error_when_request_without_token(self):
        response = client.post(EXECUTE_REPO_SET,
                               data=json.dumps(self.MOCK_ARGS),
                               headers=self.HEADERS)
        self.assertEqual(TOKEN_ERROR, response.json.get('code'))

    def test_repo_should_return_param_error_when_request_with_incorrect_args(self):
        self.MOCK_ARGS.update({"callback": True})
        response = client.post(EXECUTE_REPO_SET,
                               data=json.dumps(self.MOCK_ARGS),
                               headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(PARAM_ERROR, response.json.get('code'))

    def test_repo_should_return_400_when_request_without_args(self):
        response = client.post(EXECUTE_REPO_SET, headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(400, response.status_code)

    def test_repo_should_return_405_when_request_method_is_not_post(self):
        response = client.get(EXECUTE_REPO_SET,
                              data=json.dumps(self.MOCK_ARGS),
                              headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(405, response.status_code)

    @mock.patch.object(UserCache, 'get')
    def test_repo_should_return_token_error_when_access_token_is_error(self, mock_user):
        mock_user.return_value = None
        response = client.post(EXECUTE_REPO_SET,
                               data=json.dumps(self.MOCK_ARGS),
                               headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(TOKEN_ERROR, response.json.get('code'))

    @mock.patch('zeus.vulnerability_manage.view.query_host_basic_info')
    @mock.patch.object(UserCache, 'get')
    def test_repo_set_should_return_database_connect_error_when_cannot_connect_database(
            self, mock_user, mock_query_host_info):
        mock_user.return_value = UserInfo('admin', 'mock', 'mock')
        mock_query_host_info.return_value = DATABASE_CONNECT_ERROR, {}
        response = client.post(EXECUTE_REPO_SET,
                               data=json.dumps(self.MOCK_ARGS),
                               headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(DATABASE_CONNECT_ERROR, response.json.get('code'))

    @mock.patch('zeus.vulnerability_manage.view.query_host_basic_info')
    @mock.patch.object(UserCache, 'get')
    def test_repo_set_should_return_database_query_error_when_query_data_is_error(
            self, mock_user, mock_query_host_info):
        mock_user.return_value = UserInfo('admin', 'mock', 'mock')
        mock_query_host_info.return_value = DATABASE_QUERY_ERROR, {}
        response = client.post(EXECUTE_REPO_SET,
                               data=json.dumps(self.MOCK_ARGS),
                               headers=self.HEADERS_WITH_TOKEN)
        self.assertEqual(DATABASE_QUERY_ERROR, response.json.get('code'))

    @responses.activate
    def test_execute_task_should_return_succeed_result_when_visit_succeed(self):
        mock_args = {
            "headers": {},
            "host_id": "mock_host_id",
            "check": False,
            "host_name": "moK_host_name",
            "host_ip": "mock_ip",
            "address": "mock_address",
            "task_info": {
                "check_items": [],
                "task_id": "mock_task_id",
                "repo_info": {
                    "name": "mock_name",
                    "dest": "mock_dest",
                    "repo_content": "mock_content"
                },
                "callback": '',
            },
            "headers_apollo": {}
        }
        expect_result = {
            'code': SUCCEED,
            'msg': 'operate succeed',
            'host_id': 'mock_host_id',
            'task_id': 'mock_task_id',
            'host_name': 'moK_host_name',
            'host_ip': 'mock_ip',
            'repo': 'mock_name',
            'callback': '',
            "headers_apollo": {}
        }
        responses.add(responses.POST,
                      f"http://mock_address{CERES_CVE_REPO_SET}",
                      json={'code': SUCCEED, 'msg': 'operate succeed'},
                      status=SUCCEED,
                      content_type='application/json'
                      )
        result = ExecuteRepoSetTask()._execute_task(mock_args)
        self.assertEqual(expect_result, result)
