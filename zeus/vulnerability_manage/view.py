#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import copy
from concurrent.futures import Future
from typing import Dict, List, Tuple

from flask import Response, jsonify, request

from vulcanus.log.log import LOGGER
from vulcanus.multi_thread_handler import MultiThreadHandler
from vulcanus.restful.response import BaseResponse
from vulcanus.restful.status import (
    DATABASE_CONNECT_ERROR,
    SUCCEED,
    TOKEN_ERROR
)
from zeus.account_manager.cache import UserCache
from zeus.conf import configuration
from zeus.conf.constant import CERES_CVE_REPO_SET, CERES_CVE_SCAN, CveTaskStatus, CERES_CVE_FIX
from zeus.database import SESSION
from zeus.database.proxy.host import HostProxy
from zeus.function.verify.vulnerability import CveScanSchema, RepoSetSchema, CveFixSchema


def query_host_basic_info(host_list: List[str], username: str) -> Tuple[int, Dict]:
    """
    Query host info from database by host id

    Args:
        host_list(list): host id list
        username(str): username

    Returns:
        int: status code
        dict: e.g
            {
                host_id:{
                    name: host_name,
                    ip: host_ip,
                    address: host_ip:host_port
                }
            }
    """
    proxy = HostProxy()
    if proxy.connect(SESSION) is None:
        LOGGER.error("connect to database error")
        return DATABASE_CONNECT_ERROR, {}

    status_code, host_infos = proxy.get_host_info({
        "host_list": host_list,
        "username": username
    })
    if status_code == SUCCEED:
        result = {}
        for host_info in host_infos.get('host_infos'):
            result[host_info.get("host_id")] = {
                "host_name": host_info.get("host_name"),
                "host_ip": host_info.get("public_ip"),
                "address": f"{host_info.get('public_ip')}:{host_info.get('agent_port')}"
            }
        return SUCCEED, result
    return status_code, {}


def generate_tasks(tasks: List, host_infos: Dict, **kwargs: Dict) -> List:
    """
    Generate parameter groups for multi threading handler

    Args:
        tasks(list): e.g
            [{
                "host_id": "host_id",
                "check": False
            }]
        host_infos(dict): e.g
            {
                "host_id": {
                    "host_name": "host_name",
                    "host_ip": "host_ip",
                    "address": "ip:port"
                }
            }
        **kwargs(dict): other task data

    Returns:
        list: e.g
            [{
                "host_id": "host_id",
                "check": False,
                "host_name": "host_name",
                "host_ip": "host_ip",
                "address": "ip:port",
                ...(other task data)
            }]
    """
    new_tasks = []
    for task in tasks:
        if host_infos.get(task.get('host_id')) is not None:
            task.update(host_infos.get(task.get('host_id')))
            task.update(kwargs)
            new_tasks.append(task)
    return new_tasks


class ExecuteRepoSetTask(BaseResponse):
    """
    Interface for repo set.
    Restful API: post
    """

    def _handle(self, data: Dict) -> Tuple:
        """
        Handle function

        Args:
            data (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "repo set",
                "total_hosts": ["host_id1", "host_id2"],
                "check_items": [],
                "repo_info": {
                    "name": "openEuler2203",
                    "dest": "/etc/yum.repos.d/aops-update.repo",
                    "repo_content": "update"
                    },
                "tasks": [
                    {
                        "host_id": "host_id1",
                        "check": false
                    },
                    {
                        "host_id": "host_id2",
                        "check": false
                    }
                ],
                "callback":"/vulnerability/task/callback/repo/set",
                "username": "admin"
            }

        Returns:
            tuple: (status code, result)
        """
        # Generate headers
        user = UserCache.get(data.get('username'))
        if user is None:
            return TOKEN_ERROR, {}

        # Query host basic info from database
        status_code, host_infos = query_host_basic_info(data.get('total_hosts'),
                                                        data.get('username'))
        if status_code != SUCCEED:
            return status_code, {}

        # Generate tasks
        old_tasks = data.get('tasks')
        task_data = {
            "task_info": {
                "task_id": data.get("task_id"),
                "repo_info": data.get("repo_info"),
                "callback": data.get("callback"),
                "check_items": data.get("check_items")
            },
            "headers_ceres": {'content-type': 'application/json', 'access_token': user.token},
            "headers_apollo": {
                'content-type': 'application/json',
                'access_token': request.headers.get('access_token')},
        }
        new_tasks = generate_tasks(old_tasks, host_infos, **task_data)

        # Execute task
        task_handler = MultiThreadHandler(self._execute_task, new_tasks, None)
        if data.get('callback'):
            task_handler.create_thread(call_back=self._callback)
        else:
            task_handler.create_thread()

        # Generate target data
        result = {
            "result": {
                "task_id": data.get("task_id"),
                "task_name": data.get("task_name"),
                "task_type": data.get("task_type"),
                "task_result": self._convert_execution_result_to_target_data_format(
                    task_handler.get_result(), data.get("total_hosts"))
            }
        }

        return SUCCEED, result

    def _execute_task(self, data: Dict) -> Dict:
        """
        Execute repo set task and return its result

        Args:
            data(dict): request parameters

        Returns:
            dict: e.g
                {
                  "code": 200,
                  "msg": "operate succeed",
                  "host_id": "host_id",
                  "task_id": "task_id",
                  "host_name": "host_name",
                  "host_ip": "127.0.0.1,
                  "repo": "openEuler22.03",
                  "callback": "/vulnerability/task/callback/repo/set",
                  "headers_apollo": {'content-type': 'application/json', 'access_token': "token"}
                }
        """
        host_id = data.get("host_id")
        request_args = {
            "check": data.get("check"),
            "repo_info": data.get("task_info").get("repo_info"),
            "check_items": data.get("task_info").get("check_items")
        }
        url = f'http://{data.get("address")}{CERES_CVE_REPO_SET}'
        result = self.get_response("post", url, request_args, data.get('headers_ceres'))
        result.update({
            "host_id": host_id,
            "task_id": data.get("task_info").get("task_id"),
            "host_name": data.get("host_name"),
            "host_ip": data.get("host_ip"),
            "repo": data.get("task_info").get("repo_info").get("name"),
            "callback": data.get("task_info").get("callback"),
            "headers_apollo": data.get("headers_apollo")
        })
        return result

    def _callback(self, future: Future) -> None:
        result = copy.deepcopy(future.result())
        if result.pop('code', '') == SUCCEED:
            result['status'] = CveTaskStatus.SUCCEED
        else:
            result['status'] = CveTaskStatus.FAIL
        result['repo_name'] = result.pop('repo', '')
        result.pop('msg')
        result.pop('host_name')
        result.pop('host_ip')
        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{result.pop("callback")}'
        self.get_response("post", url, result, result.pop("headers_apollo"))

    @staticmethod
    def _convert_execution_result_to_target_data_format(result_list: List,
                                                        total_host_list: List) -> List:
        """
        convert task result to target format

        Args:
            result_list(list): all tasks execution result
            total_host_list(list): host id list

        Returns:
            list: e.g
                {
                    "host_id": "host id",
                    "host_ip": "host ip",
                    "host_name": "host name",
                    "log": "string ",
                    "repo": "repo name",
                    "status": "succeed"
                }
        """
        task_result = []
        for execute_result in result_list:
            if execute_result.get('code') == SUCCEED:
                execute_result.update({
                    "log": execute_result.pop('msg'),
                    "status": CveTaskStatus.SUCCEED
                })
            else:
                execute_result.update({
                    "log": f"{execute_result.get('code')},{execute_result.pop('msg')}",
                    "status": CveTaskStatus.FAIL
                })
            execute_result.pop("headers_apollo")
            execute_result.pop("code")
            execute_result.pop("task_id")
            execute_result.pop("callback")
            total_host_list.remove(execute_result.get("host_id"))
            task_result.append(execute_result)

        for invalid_host_id in total_host_list:
            task_result.append({
                "host_id": invalid_host_id,
                "host_name": "",
                "host_ip": "",
                "repo": "",
                "log": "No matching data found in the database.",
                "status": CveTaskStatus.UNKNOWN
            })

        return task_result

    def post(self) -> Response:
        """
        execute repo set task

        Returns:
            response body
        """
        return jsonify(self.handle_request(RepoSetSchema, self))


class ExecuteCveScanTask(BaseResponse):
    """
    Interface for cve scan.
    Restful API: POST
    """

    def _handle(self, data: dict) -> Tuple[int, dict]:
        """
        Handle function

        Args:
            data (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "cve scan",
                "total_hosts": ["host_id1", "host_id2"],
                "check_items": [],
                "tasks": [
                    {
                        "host_id": "host_id1",
                        "check": false
                    },
                    {
                        "host_id": "host_id2",
                        "check": false
                    }
                ],
                "callback":"/vulnerability/task/callback/cve/scan",
                "username": "admin"
            }

        Returns:
            tuple: (status code, result)
        """
        # Generate headers
        user = UserCache.get(data.get('username'))
        if user is None:
            return TOKEN_ERROR, {}

        # Query host basic info from database
        status_code, host_infos = query_host_basic_info(data.get('total_hosts'),
                                                        data.get('username'))
        if status_code != SUCCEED:
            return status_code, {}

        # Generate tasks
        self._callback_url = data.get('callback')
        self._user_token = {'content-type': 'application/json',
                            'access_token': request.headers.get('access_token')}
        self._host_token = {'content-type': 'application/json',
                            'access_token': user.token}
        self._task_id = data.get("task_id")
        self._check_items = data.get('check_items')
        tasks = generate_tasks(data.get('tasks'), host_infos)

        # Execute task
        task_handler = MultiThreadHandler(self._execute_task, tasks, None)
        if data.get('callback'):
            task_handler.create_thread(call_back=self._callback)
        else:
            task_handler.create_thread()

        total_hosts = data.get("total_hosts")
        valid_result = task_handler.get_result()
        task_result = self._convert_execution_result_to_target_data_format(
            valid_result, total_hosts)
        return SUCCEED, {"task_result": task_result}

    def _execute_task(self, task_info: dict) -> dict:
        """
        Execute cve scan task and return its result

        Args:
            task_info (dict): e.g
                {
                    "host_id": "host_id",
                    "check": true,
                    "address": "127.0.0.1:12000",
                    "host_name": 'host_name',
                }

        Returns:
            dict: e.g
                {
                  "code": 200,
                  "msg": "operate succeed",
                  "host_id": "host_id",
                  "result": {
                    "cves": ["cve_id_1", "cve_id_2"],
                    "os_version": "openEuler 22.03 LTS",
                    "installed_packages": ["package_1", "package_2"],
                  }
                }
        """
        request_args = {
            "check_items": self._check_items,
            "check": task_info.get("check"),
            "basic": True
        }
        url = f'http://{task_info.get("address")}{CERES_CVE_SCAN}'
        result = self.get_response("post", url, request_args, self._host_token)
        result.update({"host_id": task_info.get("host_id")})
        return result

    def _callback(self, future: Future) -> None:
        """
        Callback function for cve scan task

        Args:
           future: A Future representing the given call.
               we can get thread execute result by
               future.result().

        Returns:
            Noreturn

        """
        result = future.result()
        request_args = {
            "task_id": self._task_id,
            "host_id": result.get("host_id"),
            "installed_packages": result.get("result", {}).get("installed_packages", []),
            "os_version": result.get("result", {}).get("os_version", ""),
            "cves": result.get("result", {}).get("cves", []),
        }
        if result.get('code', '') == SUCCEED:
            request_args['status'] = CveTaskStatus.SUCCEED
        else:
            request_args['status'] = CveTaskStatus.FAIL

        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{self._callback_url}'
        self.get_response("post", url, request_args, self._user_token)

    @staticmethod
    def _convert_execution_result_to_target_data_format(execute_result_list: list,
                                                        total_host_list: list) -> list:
        """
        convert task result to target format

        Args:
            execute_result_list(list): all tasks execution result
            total_host_list(list): host id list

        Returns:
            list: e.g
                [{
                    "host_id": "host_id",
                    "log": "operate succeed",
                    "status": "succeed",
                }]

        """
        task_result = []
        for execute_result in execute_result_list:
            res = {
                "host_id": execute_result.get('host_id'),
                "log": execute_result.get('msg'),
                "status": CveTaskStatus.SUCCEED if execute_result.get(
                    'code') == SUCCEED else CveTaskStatus.FAIL
            }
            execute_result.pop("result", None)
            total_host_list.remove(execute_result.get("host_id"))
            task_result.append(res)

        for invalid_host_id in total_host_list:
            task_result.append({
                "host_id": invalid_host_id,
                "log": "No matching data found in the database.",
                "status": CveTaskStatus.UNKNOWN,
            })
        return task_result

    def post(self) -> Response:
        """
        execute cve scan task

        Returns:
            response body
        """
        return jsonify(self.handle_request(CveScanSchema, self))


class ExecuteCveFixTask(BaseResponse):
    """
    Interface for cve fix.
    Restful API: POST
    """

    def _handle(self, data: dict) -> Tuple[int, dict]:
        """
        Handle function

        Args:
            data (dict): e.g
                {
                    "task_id": task_id",
                    "task_name":"task_name",
                    "task_type": "cve fix",
                    "total_hosts": ["host_id"],
                    "check_items": [],
                    "tasks": [
                        {
                            "host_id": "host_id",
                            "check": false,
                            "cves":["CVE-2021-3782","CVE-2021-37822"]
                        }
                    "callback":"/vulnerability/task/callback/cve/fix"
                }
        Returns:
            tuple: (status code, result)
        """
        user = UserCache.get(data.get('username'))
        if user is None:
            return TOKEN_ERROR, {}

        # Query host basic info from database
        status_code, host_infos = query_host_basic_info(data.get('total_hosts'),
                                                        data.get('username'))
        if status_code != SUCCEED:
            return status_code, {}
        # Generate tasks
        self._callback_url = data.get('callback', '')
        self._user_token = {'content-type': 'application/json',
                            'access_token': request.headers.get('access_token')}
        self._host_token = {'content-type': 'application/json',
                            'access_token': user.token}
        self._task_id = data.get("task_id")
        self._task_name = data.get("task_name")
        self._check_items = data.get('check_items')
        tasks = generate_tasks(data.get('tasks'), host_infos)

        # Execute task
        task_handler = MultiThreadHandler(self._execute_task, tasks, None)
        if self._callback_url:
            task_handler.create_thread(call_back=self._callback)
        else:
            task_handler.create_thread()

        # Generate target data
        result = {
            "result": {
                "task_id": self._task_id,
                "task_name": self._task_name,
                "task_result": self._convert_result_to_target_data_format(task_handler.get_result(),
                                                                          data.get("total_hosts"))
            }
        }
        return SUCCEED, result

    def _execute_task(self, task_info: dict) -> dict:
        """
        Execute cve fix task

        Args:
            task_info (dict): e.g
                {
                    "host_id": "host_id",
                    "host_name": "host_name",
                    "check": false,
                    "cves": ["CVE-2021-3782","CVE-2021-37822"],
                    "address": "127.0.0.1:8000"
                }

        Returns:
            dict: e.g
                {
                    "code": 200,
                    "msg": "operate success",
                    "result": [
                        {
                          "cve_id": "CVE-2021-37822",
                          "log": "fix succeed",
                          "result": "fixed"
                        }
                    ],
                    "host_id": "host_id",
                    "host_name": "host_name",
                    "host_ip": "127.0.0.1"
                }
        """
        host_id = task_info.get("host_id")
        request_args = {
            "check_items": self._check_items,
            "check": task_info.get("check"),
            "cves": task_info.get("cves")
        }
        url = f'http://{task_info.get("address")}{CERES_CVE_FIX}'
        result = self.get_response("post", url, request_args, self._host_token)
        result.update({
            "host_id": host_id,
            "host_name": task_info.get("host_name"),
            "host_ip": task_info.get("host_ip"),
        })
        return result

    def _callback(self, future: Future) -> None:
        """
        Callback function for cve fix task

        Args:
           future: A Future representing the given call.
               we can get thread execute result by
               future.result().

        Returns:
            Noreturn

        """
        result = future.result()
        request_args = {
            "task_id": self._task_id,
            "host_id": result.get("host_id"),
            "cves": {}
        }
        for cve in result.get('result', []):
            request_args['cves'][cve.get('cve_id')] = cve.get('result')

        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{self._callback_url}'
        self.get_response("post", url, request_args, self._user_token)

    @staticmethod
    def _convert_result_to_target_data_format(result_list: list, total_host_list: list) -> list:
        """
        convert task result to target format

        Args:
            execute_result_list(list): all tasks execution result
            total_host_list(list): host id list

        Returns:
            list: e.g
                [{
                "host_id": "host_id,
                "host_ip": "127.0.0.1',
                "host_name": "host_name',
                "status": "succeed",
                "log": "cve fix succeed",
                "cves": ["CVE-2021-37822"],
                "check_items": []
                }]

        """
        task_result = []
        for result in result_list:
            res = {
                "host_id": result.get('host_id'),
                "host_ip": result.get('host_ip'),
                "host_name": result.get('host_name'),
                "cves": result.get('result', []),
                "check_items": result.get('check_items', []),
                "log": result.get('msg')
            }
            if result.get('code', '') == SUCCEED:
                res.update({"status": CveTaskStatus.SUCCEED})
            else:
                res.update({"status": CveTaskStatus.FAIL})
            total_host_list.remove(result.get('host_id'))
            task_result.append(res)

        for invalid_host_id in total_host_list:
            task_result.append({
                "host_id": invalid_host_id,
                "host_ip": '',
                "host_name": '',
                "status": CveTaskStatus.UNKNOWN,
                "log": "No matching data found in the database.",
                "cves": [],
                "check_items": []
            })
        return task_result

    def post(self) -> Response:
        """
        execute cve fix task

        Returns:
            response body
        """
        return jsonify(self.handle_request(CveFixSchema, self))
