#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import copy
from concurrent.futures import Future
from typing import Dict, List, Tuple

from flask import Response, jsonify, request

from vulcanus.log.log import LOGGER
from vulcanus.multi_thread_handler import MultiThreadHandler
from vulcanus.restful.response import BaseResponse
from vulcanus.restful.status import (
    DATABASE_CONNECT_ERROR,
    SUCCEED,
    TOKEN_ERROR
)
from zeus.account_manager.cache import UserCache
from zeus.conf import configuration
from zeus.conf.constant import CERES_CVE_REPO_SET, CVE_TASK_STATUS
from zeus.database import SESSION
from zeus.database.proxy.host import HostProxy
from zeus.function.verify.vulnerability import RepoSetSchema


def query_host_basic_info(host_list: List[str], username: str) -> Tuple[int, Dict]:
    """
    Query host info from database by host id

    Args:
        host_list(list): host id list
        username(str): username

    Returns:
        int: status code
        dict: e.g
            {
                host_id:{
                    name: host_name,
                    ip: host_ip,
                    address: host_ip:host_port
                }
            }
    """
    proxy = HostProxy()
    if proxy.connect(SESSION) is None:
        LOGGER.error("connect to database error")
        return DATABASE_CONNECT_ERROR, {}

    status_code, host_infos = proxy.get_host_info({
        "host_list": host_list,
        "username": username
    })
    if status_code == SUCCEED:
        result = {}
        for host_info in host_infos.get('host_infos'):
            result[host_info.get("host_id")] = {
                "host_name": host_info.get("host_name"),
                "host_ip": host_info.get("public_ip"),
                "address": f"{host_info.get('public_ip')}:{host_info.get('agent_port')}"
            }
        return SUCCEED, result
    return status_code, {}


def generate_tasks(tasks: List, host_infos: Dict, **kwargs: Dict) -> List:
    """
    Generate parameter groups for multi threading handler

    Args:
        tasks(list): e.g
            [{
                "host_id": "host_id",
                "check": False
            }]
        host_infos(dict): e.g
            {
                "host_id": {
                    "host_name": "host_name",
                    "host_ip": "host_ip",
                    "address": "ip:port"
                }
            }
        **kwargs(dict): other task data

    Returns:
        list: e.g
            [{
                "host_id": "host_id",
                "check": False,
                "host_name": "host_name",
                "host_ip": "host_ip",
                "address": "ip:port",
                ...(other task data)
            }]
    """
    new_tasks = []
    for task in tasks:
        if host_infos.get(task.get('host_id')) is not None:
            task.update(host_infos.get(task.get('host_id')))
            task.update(kwargs)
            new_tasks.append(task)
    return new_tasks


class ExecuteRepoSetTask(BaseResponse):
    """
    Interface for repo set.
    Restful API: post
    """

    def _handle(self, data: Dict) -> Tuple:
        """
        Handle function

        Args:
            data (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "repo set",
                "total_hosts": ["host_id1", "host_id2"],
                "check_items": [],
                "repo_info": {
                    "name": "openEuler2203",
                    "dest": "/etc/yum.repos.d/aops-update.repo",
                    "repo_content": "update"
                    },
                "tasks": [
                    {
                        "host_id": "host_id1",
                        "check": false
                    },
                    {
                        "host_id": "host_id2",
                        "check": false
                    }
                ],
                "callback":"/vulnerability/task/callback/repo/set",
                "username": "admin"
            }

        Returns:
            tuple: (status code, result)
        """
        # Generate headers
        user = UserCache.get(data.get('username'))
        if user is None:
            return TOKEN_ERROR, {}

        # Query host basic info from database
        status_code, host_infos = query_host_basic_info(data.get('total_hosts'),
                                                        data.get('username'))
        if status_code != SUCCEED:
            return status_code, {}

        # Generate tasks
        old_tasks = data.get('tasks')
        task_data = {
            "task_info": {
                "task_id": data.get("task_id"),
                "repo_info": data.get("repo_info"),
                "callback": data.get("callback"),
                "check_items": data.get("check_items")
            },
            "headers_ceres": {'content-type': 'application/json', 'access_token': user.token},
            "headers_apollo": {
                'content-type': 'application/json',
                'access_token': request.headers.get('access_token')},
        }
        new_tasks = generate_tasks(old_tasks, host_infos, **task_data)

        # Execute task
        task_handler = MultiThreadHandler(self._execute_task, new_tasks, None)
        if data.get('callback'):
            task_handler.create_thread(call_back=self._callback)
        else:
            task_handler.create_thread()

        # Generate target data
        result = {
            "result": {
                "task_id": data.get("task_id"),
                "task_name": data.get("task_name"),
                "task_type": data.get("task_type"),
                "task_result": self._convert_execution_result_to_target_data_format(
                    task_handler.get_result(), data.get("total_hosts"))
            }
        }

        return SUCCEED, result

    def _execute_task(self, data: Dict) -> Dict:
        """
        Execute repo set task and return its result

        Args:
            data(dict): request parameters

        Returns:
            dict: e.g
                {
                  "code": 200,
                  "msg": "operate succeed",
                  "host_id": "host_id",
                  "task_id": "task_id",
                  "host_name": "host_name",
                  "host_ip": "127.0.0.1,
                  "repo": "openEuler22.03",
                  "callback": "/vulnerability/task/callback/repo/set",
                  "headers_apollo": {'content-type': 'application/json', 'access_token': "token"}
                }
        """
        host_id = data.get("host_id")
        request_args = {
            "check": data.get("check"),
            "repo_info": data.get("task_info").get("repo_info"),
            "check_items": data.get("task_info").get("check_items")
        }
        url = f'http://{data.get("address")}{CERES_CVE_REPO_SET}'
        result = self.get_response("post", url, request_args, data.get('headers_ceres'))
        result.update({
            "host_id": host_id,
            "task_id": data.get("task_info").get("task_id"),
            "host_name": data.get("host_name"),
            "host_ip": data.get("host_ip"),
            "repo": data.get("task_info").get("repo_info").get("name"),
            "callback": data.get("task_info").get("callback"),
            "headers_apollo": data.get("headers_apollo")
        })
        return result

    def _callback(self, future: Future) -> None:
        result = copy.deepcopy(future.result())
        if result.pop('code', '') == SUCCEED:
            result['status'] = 'set'
        else:
            result['status'] = 'unset'
        result['repo_name'] = result.pop('repo', '')
        result.pop('msg')
        result.pop('host_name')
        result.pop('host_ip')

        headers = {'content-type': 'application/json', 'access_token': "admin"}
        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{result.pop("callback")}'
        self.get_response("post", url, result, headers)

    @staticmethod
    def _convert_execution_result_to_target_data_format(result_list: List,
                                                        total_host_list: List) -> List:
        """
        convert task result to target format

        Args:
            result_list(list): all tasks execution result
            total_host_list(list): host id list

        Returns:
            list: e.g
                {
                    "host_id": "host id",
                    "host_ip": "host ip",
                    "host_name": "host name",
                    "log": "string ",
                    "repo": "repo name",
                    "status": "succeed"
                }
        """
        task_result = []
        for execute_result in result_list:
            if execute_result.get('code') == SUCCEED:
                execute_result.update({
                    "log": execute_result.pop('msg'),
                    "status": CVE_TASK_STATUS.get("succeed")
                })
            else:
                execute_result.update({
                    "log": f"{execute_result.get('code')},{execute_result.pop('msg')}",
                    "status": CVE_TASK_STATUS.get("fail")
                })
            execute_result.pop("headers_apollo")
            execute_result.pop("code")
            execute_result.pop("task_id")
            execute_result.pop("callback")
            total_host_list.remove(execute_result.get("host_id"))
            task_result.append(execute_result)

        for invalid_host_id in total_host_list:
            task_result.append({
                "host_id": invalid_host_id,
                "host_name": "",
                "host_ip": "",
                "repo": "",
                "log": "No matching data found in the database.",
                "status": CVE_TASK_STATUS.get("unknown")
            })

        return task_result

    def post(self) -> Response:
        """
        execute repo set task

        Returns:
            response body
        """
        return jsonify(self.handle_request(RepoSetSchema, self))
