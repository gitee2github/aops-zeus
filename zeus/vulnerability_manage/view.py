#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import json
from concurrent.futures import Future
from typing import Dict, Tuple

from flask import Response, g, request

from vulcanus.log.log import LOGGER
from vulcanus.multi_thread_handler import MultiThreadHandler
from vulcanus.restful.resp import state
from vulcanus.restful.response import BaseResponse
from zeus.conf import configuration
from zeus.conf.constant import CERES_CVE_FIX, CERES_CVE_REPO_SET, CERES_CVE_SCAN, CveTaskStatus
from zeus.database.proxy.host import HostProxy
from zeus.function.model import ClientConnectArgs
from zeus.function.verify.vulnerability import CveFixSchema, CveScanSchema, RepoSetSchema
from zeus.host_manager.ssh import execute_command_and_parse_its_result


def query_host_basic_info(host_list: list, username: str) -> Tuple[str, Dict]:
    """
    Query host info from database by host id

    Args:
        host_list(list): host id list
        username(str): username

    Returns:
        str: status code
        dict: e.g
            {
                host_id:{
                    "host_id": 1 //host_id,
                    "host_ip": "127.0.0.1",
                    "host_name": "test-1",
                    "ssh_user":"root",
                    "ssh_port": 22,
                    "pkey": "RSA-KEY string",
                }
            }
    """
    proxy = HostProxy()
    if not proxy.connect(g.session):
        LOGGER.error("connect to database error")
        return state.DATABASE_CONNECT_ERROR, {}

    status_code, host_infos = proxy.get_host_info({
        "host_list": host_list,
        "username": username
    })
    if status_code != state.SUCCEED:
        return status_code, {}
    result = {}
    for host in host_infos:
        result[host.get("host_id")] = {
            "host_id": host.get("host_id"),
            "host_ip": host.get("host_ip"),
            "host_name": host.get("host_name"),
            "ssh_user": host.get("ssh_user"),
            "ssh_port": host.get("ssh_port"),
            "pkey": host.get("pkey"),
        }
    return state.SUCCEED, result


def generate_tasks(tasks: list, host_infos: dict, **kwargs: dict) -> list:
    """
    Generate parameter groups for multi threading handler

    Args:
        tasks(list): e.g
            [{
                "host_id": "host_id",
                "check": False
            }]
        host_infos(dict): e.g
            {
                "host_id": {
                    "host_id": 1 //host_id,
                    "host_ip": "127.0.0.1",
                    "host_name": "test-1",
                    "ssh_user":"root",
                    "ssh_port": 22,
                    "pkey": "RSA-KEY string",
                }
            }
        **kwargs(dict): other task info

    Returns:
        list: e.g
            [(host_info_1,task_info),(host_info_2,task_info),...]
    """
    new_tasks = []
    for task in tasks:
        if task.get("host_id") in host_infos:
            task.update(host_infos.get(task.get('host_id')))
            task.update(kwargs)
            new_tasks.append((host_infos.get(task.get('host_id')), task))
    return new_tasks


class ExecuteRepoSetTask(BaseResponse):
    """
    Interface for repo set.
    Restful API: post
    """

    def _execute_task(self, host_info: dict, task_info: dict) -> dict:
        """
        Execute repo set task and return its result

        Args:
            host_info(dict): e.g
                {
                    "host_id": "host_id",
                    "host_ip": "host_ip",
                    "ssh_port": 22,
                    "ssh_user": "ssh_user",
                    "pkey": "rsa-key-string",
                }
            task_info (dict): e.g
                {
                    "check": true
                }

        Returns:
            dict: e.g
                {
                  "code": 200,
                  "msg": "operate succeed",
                  "host_id": "host_id",
                  "host_name": "host_name",
                  "host_ip": "127.0.0.1,
                  "repo": "openEuler22.03",
                }
        """

        def update_host_basic_info(data=None) -> dict:
            """
            add host basic information  and repo name to data

            Args:
                data (dict): task execute result

            Returns:
                dict
            """
            if data is None:
                data = {}
            data.update({
                "host_id": host_info.get("host_id"),
                "host_ip": host_info.get("host_ip"),
                "host_name": host_info.get("host_name"),
                "repo": task_info.get("repo_info").get("name")
            })
            return data

        command_args = {
            "check": task_info.get("check"),
            "repo_info": task_info.get("repo_info"),
            "check_items": self._check_items
        }
        command = CERES_CVE_REPO_SET % json.dumps(
            command_args)
        status, repo_set_result = execute_command_and_parse_its_result(ClientConnectArgs(
            host_info.get("host_ip"), host_info.get("ssh_port"), host_info.get("ssh_user"),
            host_info.get("pkey"), 60 * 10), command)
        if status != state.SUCCEED:
            return update_host_basic_info({"msg": repo_set_result})
        return update_host_basic_info(json.loads(repo_set_result))

    def _callback(self, future: Future) -> None:
        """
        Callback function for cve fix task

        Args:
           future: A Future representing the given call.
               we can get thread execute result by
               future.result().

        Returns:
            Noreturn

        """
        result = future.result()
        request_args = {
            "host_id": result.get("host_id"),
            "task_id": self._task_id,
            "repo_name": result.get("repo"),
        }

        if result.get('code') == state.SUCCEED:
            request_args['status'] = CveTaskStatus.SUCCEED
        else:
            request_args['status'] = CveTaskStatus.FAIL

        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{self._callback_url}'
        self.get_response("post", url, request_args, self._header, timeout=10)

    @staticmethod
    def _convert_result_to_target_data_format(result_list: list,
                                              total_host_list: list) -> list:
        """
        convert task result to target format

        Args:
            result_list(list): all tasks execution result
            total_host_list(list): host id list

        Returns:
            list: e.g
                {
                    "host_id": "host id",
                    "host_ip": "host ip",
                    "log": "string ",
                    "repo": "repo name",
                    "status": "succeed",
                    "check_items": []
                }
        """
        task_result = []
        for result in result_list:
            res = {
                "host_id": result.get("host_id"),
                "host_ip": result.get('host_ip'),
                "host_name": result.get('host_name'),
                "check_items": result.get('check_items', []),
                "repo": result.get('repo'),
                "log": result.get('msg'),
            }
            if result.get('code', '') == state.SUCCEED:
                res.update({"status": CveTaskStatus.SUCCEED})
            else:
                res.update({"status": CveTaskStatus.FAIL})

            if result.get("host_id"):
                total_host_list.remove(result.get("host_id"))
                task_result.append(res)

        for invalid_host_id in total_host_list:
            task_result.append({
                "host_id": invalid_host_id,
                "host_ip": "unknown host",
                "host_name": "unknown host",
                "repo": "",
                "log": "No matching data found in the database.",
                "status": CveTaskStatus.UNKNOWN
            })

        return task_result

    @BaseResponse.handle(schema=RepoSetSchema)
    def post(self, **params) -> Response:
        """
        execute repo set task

        Args:
            params (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "repo set",
                "total_hosts": ["host_id1", "host_id2"],
                "check_items": [],
                "repo_info": {
                    "name": "openEuler2203",
                    "dest": "/etc/yum.repos.d/aops-update.repo",
                    "repo_content": "update"
                    },
                "tasks": [
                    {
                        "host_id": "host_id1",
                        "check": false
                    },
                    {
                        "host_id": "host_id2",
                        "check": false
                    }
                ],
                "callback":"/vulnerability/task/callback/repo/set",
                "username": "admin"
            }

        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'),
                                                        params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # Generate tasks
        self._callback_url = params.get('callback')
        self._header = {'content-type': 'application/json',
                        'access_token': request.headers.get('access_token')}
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        self._check_items = params.get('check_items')
        tasks = generate_tasks(params.get('tasks'), host_infos,
                               **{"repo_info": params.get("repo_info")})

        # Execute task
        task_handler = MultiThreadHandler(lambda p: self._execute_task(*p), tasks, None)
        if params.get('callback'):
            task_handler.create_thread(call_back=self._callback)
        else:
            task_handler.create_thread()

        # Generate target data
        result = {
            "result": {
                "task_id": self._task_id,
                "task_name": self._task_name,
                "task_type": self._task_type,
                "task_result": self._convert_result_to_target_data_format(task_handler.get_result(),
                                                                          params.get("total_hosts"))
            }
        }
        return self.response(code=state.SUCCEED, data=result)


class ExecuteCveScanTask(BaseResponse):
    """
    Interface for cve scan.
    Restful API: POST
    """

    def _execute_task(self, host_info: dict, task_info: dict, timeout: float = None) -> dict:
        """
        Execute cve scan task and return its result

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": "host_id",
                    "host_ip": "host_ip",
                    "ssh_port": 22,
                    "ssh_user": "ssh_user",
                    "pkey": "rsa-key-string",
                }
            task_info (dict): e.g
                {
                    "check": true
                }

        Returns:
            dict: e.g
                {
                  "code": 200,
                  "msg": "operate succeed",
                  "host_id": "host_id",
                  "result": {
                    "cves": ["cve_id_1", "cve_id_2"],
                    "os_version": "openEuler 22.03 LTS",
                    "installed_packages": ["package_1", "package_2"],
                  }
                }
        """
        command_args = {
            "check_items": self._check_items,
            "check": task_info.get("check"),
            "basic": True
        }
        command = CERES_CVE_SCAN % json.dumps(command_args)

        status, cve_scan_result = execute_command_and_parse_its_result(ClientConnectArgs(
            host_info.get("host_ip"), host_info.get("ssh_port"), host_info.get("ssh_user"),
            host_info.get("pkey"), 60 * 10), command)
        if status != state.SUCCEED:
            return {"host_id": host_info.get("host_id"), "msg": cve_scan_result}
        result = json.loads(cve_scan_result)
        result.update({"host_id": host_info.get("host_id")})
        return result

    def _callback(self, future: Future) -> None:
        """
        Callback function for cve scan task

        Args:
           future: A Future representing the given call.
               we can get thread execute result by
               future.result().

        Returns:
            Noreturn

        """
        result = future.result()
        request_args = {
            "task_id": self._task_id,
            "host_id": result.get("host_id"),
            "installed_packages": result.get("result", {}).get("installed_packages", []),
            "os_version": result.get("result", {}).get("os_version", ""),
            "cves": result.get("result", {}).get("cves", []),
        }
        if result.get('code', '') == state.SUCCEED:
            request_args['status'] = CveTaskStatus.SUCCEED
        else:
            request_args['status'] = CveTaskStatus.FAIL

        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{self._callback_url}'
        self.get_response("post", url, request_args, self._header, timeout=10)

    @staticmethod
    def _convert_execution_result_to_target_data_format(execute_result_list: list,
                                                        total_host_list: list) -> list:
        """
        convert task result to target format

        Args:
            execute_result_list(list): all tasks execution result
            total_host_list(list): host id list

        Returns:
            list: e.g
                [{
                    "host_id": "host_id",
                    "log": "operate succeed",
                    "status": "succeed",
                }]

        """
        task_result = []
        for execute_result in execute_result_list:
            res = {
                "host_id": execute_result.get('host_id'),
                "log": execute_result.get('msg'),
                "status": CveTaskStatus.SUCCEED if execute_result.get(
                    'code') == state.SUCCEED else CveTaskStatus.FAIL
            }
            execute_result.pop("result", None)
            total_host_list.remove(execute_result.get("host_id"))
            task_result.append(res)

        for invalid_host_id in total_host_list:
            task_result.append({
                "host_id": invalid_host_id,
                "log": "No matching data found in the database.",
                "status": CveTaskStatus.UNKNOWN,
            })
        return task_result

    @BaseResponse.handle(schema=CveScanSchema)
    def post(self, **params) -> Response:
        """
        execute cve scan task

        Args:
            params (dict): e.g
            {
                "task_id": "task_id_1",
                "task_name":"name",
                "task_type": "cve scan",
                "total_hosts": ["host_id1", "host_id2"],
                "check_items": [],
                "tasks": [
                    {
                        "host_id": "host_id1",
                        "check": false
                    },
                    {
                        "host_id": "host_id2",
                        "check": false
                    }
                ],
                "callback":"/vulnerability/task/callback/cve/scan",
                "username": "admin"
            }

        Returns:
            response body
        """
        # Query host basic info from database
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'),
                                                        params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # Generate tasks
        self._callback_url = params.get('callback')
        self._header = {'content-type': 'application/json',
                        'access_token': request.headers.get('access_token')}
        self._task_id = params.get("task_id")
        self._check_items = params.get('check_items')
        tasks = generate_tasks(params.get('tasks'), host_infos)

        # Execute task
        task_handler = MultiThreadHandler(lambda p: self._execute_task(*p), tasks, None)
        if params.get('callback'):
            task_handler.create_thread(call_back=self._callback)
        else:
            task_handler.create_thread()

        valid_result = task_handler.get_result()
        task_result = self._convert_execution_result_to_target_data_format(
            valid_result, params.get("total_hosts"))

        return self.response(code=state.SUCCEED, data={"task_result": task_result})


class ExecuteCveFixTask(BaseResponse):
    """
    Interface for cve fix.
    Restful API: POST
    """

    def _execute_task(self, host_info: dict, task_info: dict, timeout: float = None) -> dict:
        """
        Execute cve fix task

        Args:
            "host_info"(dict): e.g
                {
                    "host_id": 1, //host id number
                    "host_ip": "127.0.0.1",
                    "host_name": "test_host",
                    "ssh_port": 22,
                    "ssh_user": "root",
                    "pkey": "RSA-KEY-string",
                }
            task_info (dict): e.g
                {
                    "check": true
                }
        Returns:
            dict: e.g
                {
                    "code": 200,
                    "msg": "operate success",
                    "result": [
                        {
                          "cve_id": "CVE-2021-37822",
                          "log": "fix succeed",
                          "result": "fixed"
                        }
                    ],
                    "host_id": 1,
                    "host_name": "test_host",
                    "host_ip": "127.0.0.1"
                }
        """

        def update_host_basic_info(data=None) -> dict:
            """
            add host basic information to data

            Args:
                data (dict): task execute result

            Returns:
                dict
            """
            if data is None:
                data = {}
            data.update({
                "host_id": host_info.get("host_id"),
                "host_ip": host_info.get("host_ip"),
                "host_name": host_info.get("host_name")
            })
            return data

        command_args = {
            "check_items": self._check_items,
            "check": task_info.get("check"),
            "cves": task_info.get("cves")
        }
        command = CERES_CVE_FIX % json.dumps(command_args)
        status, cve_fix_result = execute_command_and_parse_its_result(ClientConnectArgs(
            host_info.get("host_ip"), host_info.get("ssh_port"), host_info.get("ssh_user"),
            host_info.get("pkey"), 60 * 10), command)
        if status != state.SUCCEED:
            return update_host_basic_info({"msg": cve_fix_result})
        return update_host_basic_info(json.loads(cve_fix_result))

    def _callback(self, future: Future) -> None:
        """
        Callback function for cve fix task

        Args:
           future: A Future representing the given call.
               we can get thread execute result by
               future.result().

        Returns:
            Noreturn

        """
        result = future.result()
        request_args = {
            "task_id": self._task_id,
            "host_id": result.get("host_id"),
            "cves": {}
        }
        for cve in result.get('result', []):
            request_args['cves'][cve.get('cve_id')] = cve.get('result')

        apollo_ip = configuration.apollo.get("IP")
        apollo_port = configuration.apollo.get("PORT")
        url = f'http://{apollo_ip}:{apollo_port}{self._callback_url}'
        self.get_response("post", url, request_args, self._header, 10)

    @staticmethod
    def _convert_result_to_target_data_format(result_list: list, total_host_list: list) -> list:
        """
        convert task result to target format

        Args:
            result_list(list): all tasks execution result
            total_host_list(list): host id list

        Returns:
            list: e.g
                [{
                "host_id": "host_id,
                "host_ip": "127.0.0.1',
                "host_name": "host_name',
                "status": "succeed",
                "log": "cve fix succeed",
                "cves": ["CVE-2021-37822"],
                "check_items": []
                }]

        """
        task_result = []
        for result in result_list:
            res = {
                "host_id": result.get('host_id'),
                "host_ip": result.get('host_ip'),
                "host_name": result.get('host_name'),
                "cves": result.get('result', []),
                "check_items": result.get('check_items', []),
                "log": result.get('msg')
            }
            if result.get('code', '') == state.SUCCEED:
                res.update({"status": CveTaskStatus.SUCCEED})
            else:
                res.update({"status": CveTaskStatus.FAIL})
            total_host_list.remove(result.get('host_id'))
            task_result.append(res)

        for invalid_host_id in total_host_list:
            task_result.append({
                "host_id": invalid_host_id,
                "host_ip": 'unknown host',
                "host_name": 'unknown host',
                "status": CveTaskStatus.UNKNOWN,
                "log": "No matching data found in the database.",
                "cves": [],
                "check_items": []
            })
        return task_result

    @BaseResponse.handle(schema=CveFixSchema)
    def post(self, **params) -> Response:
        """
        execute cve fix task

        Args:
            params (dict): e.g
                {
                    "task_id": task_id",
                    "task_name":"task_name",
                    "task_type": "cve fix",
                    "total_hosts": ["host_id"],
                    "check_items": [],
                    "tasks": [
                        {
                            "host_id": "host_id",
                            "check": false,
                            "cves":["CVE-2021-3782","CVE-2021-37822"]
                        }
                    "callback":"/vulnerability/task/callback/cve/fix"
                }
        Returns:
            response body
        """
        status_code, host_infos = query_host_basic_info(params.get('total_hosts'),
                                                        params.get('username'))
        if status_code != state.SUCCEED:
            return self.response(code=status_code)
        # Generate tasks
        self._callback_url = params.get('callback')
        self._header = {'content-type': 'application/json',
                        'access_token': request.headers.get('access_token')}
        self._task_id = params.get("task_id")
        self._task_name = params.get("task_name")
        self._task_type = params.get("task_type")
        self._check_items = params.get('check_items')
        tasks = generate_tasks(params.get('tasks'), host_infos,
                               **{"repo_info": params.get("repo_info")})

        # Execute task
        task_handler = MultiThreadHandler(lambda p: self._execute_task(*p), tasks, None)
        if self._callback_url:
            task_handler.create_thread(call_back=self._callback)
        else:
            task_handler.create_thread()

        # Generate target data
        result = {
            "result": {
                "task_id": self._task_id,
                "task_name": self._task_name,
                "task_result": self._convert_result_to_target_data_format(task_handler.get_result(),
                                                                          params.get("total_hosts"))
            }
        }
        return self.response(code=state.SUCCEED, data=result)
